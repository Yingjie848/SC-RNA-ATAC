
# 1) source /home/zhuy1/my_apps/miniconda3/bin/activate /home/zhuy1/my_apps/miniconda3
# 2) python

import scrublet as scr
import scipy.io
import matplotlib.pyplot as plt
import numpy as np
import os

# Load the raw counts matrix as a scipy sparse matrix with cells as rows and genes as columns.
fcounts="MBC218_highCov_atac_20230522/seurat_cellRangerRawData/RNA_counts.txt"
counts_matrix = np.loadtxt(fcounts, dtype='i', delimiter='\t')

print('Counts matrix shape: {} rows, {} columns'.format(counts_matrix.shape[0], counts_matrix.shape[1]))

# Initialize Scrublet object
#The relevant parameters are:

#expected_doublet_rate: the expected fraction of transcriptomes that are doublets, typically 0.05-0.1. Results are not particularly sensitive to this parameter. For this example, the expected doublet rate comes from the Chromium User Guide: https://support.10xgenomics.com/permalink/3vzDu3zQjY0o2AqkkkI4CC
#sim_doublet_ratio: the number of doublets to simulate, relative to the number of observed transcriptomes. This should be high enough that all doublet states are well-represented by simulated doublets. Setting it too high is computationally expensive. The default value is 2, though values as low as 0.5 give very similar results for the datasets that have been tested.
#n_neighbors: Number of neighbors used to construct the KNN classifier of observed transcriptomes and simulated doublets. The default value of round(0.5*sqrt(n_cells)) generally works well.

scrub = scr.Scrublet(counts_matrix, expected_doublet_rate=0.06)

# Run the default pipeline, which includes:
# Doublet simulation
# Normalization, gene filtering, rescaling, PCA
# Doublet score calculation
# Doublet score threshold detection and doublet calling

doublet_scores, predicted_doublets = scrub.scrub_doublets()

# count predicted doublets
import collections
elements_count = collections.Counter(predicted_doublets)

# write out
np.savetxt("MBC218_highCov_atac_20230522/seurat_cellRangerRawData/scrublet_doublets.txt", predicted_doublets, newline="\n")
np.savetxt("MBC218_highCov_atac_20230522/seurat_cellRangerRawData/scrublet_score.txt", doublet_scores, newline="\n")


exit(0)

# Plot doublet score histograms for observed transcriptomes and simulated doublets
scrub.plot_histogram();
plt.savefig("MBC218_highCov_atac_20230522/seurat_cellRangerRawData/scrublet_doublet_score_histogram.pdf", format="pdf", bbox_inches="tight")

# The simulated doublet histogram is typically bimodal. The left mode corresponds to "embedded" doublets generated by two cells with similar gene expression. The right mode corresponds to "neotypic" doublets, which are generated by cells with distinct gene expression (e.g., different cell types) and are expected to introduce more artifacts in downstream analyses. Scrublet can only detect neotypic doublets.

# To call doublets vs. singlets, we must set a threshold doublet score, ideally at the minimum between the two modes of the simulated doublet histogram. scrub_doublets() attempts to identify this point automatically and has done a good job in this example. However, if automatic threshold detection doesn't work well, you can adjust the threshold with the call_doublets() function. For example:

scrub.call_doublets(threshold=0.25)

# Get 2-D embedding to visualize the results

print('Running UMAP...')
scrub.set_embedding('UMAP', scr.get_umap(scrub.manifold_obs_, 10, min_dist=0.3))


# Plot doublet predictions on 2-D embedding
# Predicted doublets should co-localize in distinct states
scrub.plot_embedding('UMAP', order_points=True)


